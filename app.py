import streamlit as st
import pandas as pd
import numpy as np
# Import all the necessary functions from your original script
from football_logic import * # --- 1. APP CONFIGURATION ---
st.set_page_config(
    page_title="NFL Prediction System",
    page_icon="üèà",
    layout="wide",
    initial_sidebar_state="expanded"
)

# --- 2. CACHED DATA LOADING & MODEL TRAINING ---
# @st.cache_data is perfect for loading data. It runs once, and the result is stored.
@st.cache_data
def load_all_data():
    """Load and prepare all necessary NFL data. This function is cached."""
    pbp_df, team_def_stats = get_pbp_data(HISTORICAL_YEARS)
    weekly_df = get_weekly_data(HISTORICAL_YEARS, team_def_stats)
    
    # Apply the same data prep/patching logic from your main() function
    for df in [pbp_df, weekly_df]:
        if not df.empty:
            df.columns = [col.strip().replace(" ", "_").lower() for col in df.columns]

    if 'opp_def_epa' not in weekly_df.columns or 'opp_def_success' not in weekly_df.columns:
        def_by_team_week = (pbp_df.loc[~pbp_df['defteam'].isna()]
            .groupby(['season', 'week', 'defteam'], as_index=False)
            .agg(opp_def_epa=('epa', 'mean'), opp_def_success=('epa', lambda s: (s > 0).mean()))
            .rename(columns={'defteam': 'opponent_team'}))
        weekly_df = weekly_df.merge(def_by_team_week, on=['season', 'week', 'opponent_team'], how='left')
        weekly_df['opp_def_epa'].fillna(weekly_df['opp_def_epa'].mean(), inplace=True)
        weekly_df['opp_def_success'].fillna(weekly_df['opp_def_success'].mean(), inplace=True)

    if 'rolling_yds' not in weekly_df.columns:
        weekly_df = add_rolling_features(weekly_df, window=4)
        
    for c in ["opp_def_epa", "opp_def_success", "rolling_yds", "rolling_attempts"]:
        if c not in weekly_df.columns:
            weekly_df[c] = 0.0
        weekly_df[c] = weekly_df[c].replace([np.inf, -np.inf], 0.0).fillna(0.0)

    return pbp_df, weekly_df

# @st.cache_resource is for things that can't be easily converted to a hashable data format,
# like ML models or database connections. This is the perfect tool here.
@st.cache_resource
def train_all_models(_pbp_df, _weekly_df):
    """Train all models. This function is also cached."""
    models_dict = {}
    
    # 1. Win Probability Model
    try:
        model, scaler, stats, loss = train_enhanced_win_prob_model(
            _pbp_df, use_neural=False, use_stacking=False, calibrate=True
        )
        if model:
            models_dict['binary'] = (model, scaler, stats, loss)
    except Exception as e:
        st.error(f"Failed to train win probability model: {e}")

    # 2. Spread Model
    try:
        model, scaler, stats, loss = train_spread_model_huber(_pbp_df)
        if model:
            models_dict['spread'] = (model, scaler, stats, loss)
    except Exception as e:
        st.error(f"Failed to train spread model: {e}")

    # 3. Total Points Model
    try:
        model, scaler, stats, loss = train_enhanced_points_model(_pbp_df)
        if model:
            models_dict['total'] = (model, scaler, stats, loss)
    except Exception as e:
        st.error(f"Failed to train total points model: {e}")

    # 4. Player Models
    try:
        team_stats_for_players = models_dict.get('spread', models_dict.get('binary', (None, None, None)))[2]
        if team_stats_for_players is not None:
            player_models = train_player_yardage_models_hierarchical(_weekly_df, team_stats_for_players)
            models_dict['players'] = player_models
    except Exception as e:
        st.error(f"Failed to train player models: {e}")
    
    # In app.py -> train_all_models()

    # --- 5. NEURAL NETWORK MODELS ---
    # This section trains the advanced models after the traditional ones are ready.
    neural_models = {}
    if 'binary' in models_dict:
        # Neural models depend on the stats generated by the traditional binary model.
        team_stats_for_neural = models_dict['binary'][2]

        # a. Neural Win Probability Model
        try:
            st.write("üß† Training Neural Win Probability Model...")
            win_model, win_encoder, _ = train_neural_win_prob_model(team_stats_for_neural)
            if win_model and win_encoder:
                neural_models['neural_binary'] = (win_model, win_encoder, team_stats_for_neural)
        except Exception as e:
            st.error(f"Failed to train neural win probability model: {e}")

        # b. Neural Player Models
        try:
            st.write("üß† Training Neural Player Models...")
            neural_player_models = {}
            player_data_dict = {
                'QB': _weekly_df[_weekly_df['position'] == 'QB'].copy(),
                'WR': _weekly_df[_weekly_df['position'] == 'WR'].copy(),
                'TE': _weekly_df[_weekly_df['position'] == 'TE'].copy(),
                'RB': _weekly_df[_weekly_df['position'] == 'RB'].copy()
            }
            for position in ['QB', 'WR', 'TE', 'RB']:
                if not player_data_dict[position].empty:
                    target_col = 'passing_yards' if position == 'QB' else 'rushing_yards' if position == 'RB' else 'receiving_yards'
                    # The function returns 4 items: model, encoder, data, and target_scaler
                    model, encoder, data, scaler = train_neural_player_model(
                        player_data_dict[position], position, target_col
                    )
                    if model and encoder and scaler:
                        neural_player_models[position] = (model, encoder, data, scaler)
            neural_models['neural_players'] = neural_player_models
        except Exception as e:
            st.error(f"Failed to train neural player models: {e}")
            
    models_dict['neural'] = neural_models
        
    return models_dict


# --- 3. UI HELPER FUNCTIONS FOR EACH TAB ---

def display_home_page(pbp_df, weekly_df, models_dict):
    st.header("Welcome to the Enhanced NFL Prediction System üöÄ")
    st.markdown("""
    This application leverages a suite of machine learning models to provide predictions for NFL games. 
    All data is loaded and models are trained once at startup to ensure a fast user experience.

    **Navigate using the sidebar to:**
    - `Game Outcome`: Predict win/loss probabilities for a matchup.
    - `Point Spread`: Forecast the point differential between two teams.
    - `Total Points`: Predict the combined score for a game (Over/Under).
    - `Player Yardage`: Get yardage projections for individual players.
    """)

    st.subheader("Data & Model Status")
    col1, col2, col3 = st.columns(3)
    with col1:
        st.metric("PBP Data Rows", f"{len(pbp_df):,}")
    with col2:
        st.metric("Weekly Data Rows", f"{len(weekly_df):,}")
    with col3:
        st.metric("Models Trained", f"{len(models_dict)}")
    
    if models_dict:
        st.success("‚úÖ All data loaded and models trained successfully!")
    else:
        st.warning("‚ö†Ô∏è Models are still training or an error occurred. Please check logs.")


def display_binary_outcome_tab(models_dict):
    st.header("üèà Game Outcome Prediction")
    if 'binary' not in models_dict:
        st.warning("Binary outcome model is not available.")
        return

    model_info, scaler, team_stats, _ = models_dict['binary']
    available_teams = sorted(team_stats['team'].unique())
    
    col1, col2 = st.columns(2)
    with col1:
        home_team = st.selectbox("Select Home Team", available_teams, index=0)
    with col2:
        # Default away team to the second team in the list to avoid duplicates
        away_team = st.selectbox("Select Away Team", available_teams, index=1)

    if st.button("Predict Win Probability", type="primary"):
        if home_team == away_team:
            st.error("Home and Away teams cannot be the same.")
            return

        with st.spinner("Calculating..."):
            # This logic is adapted directly from your run_enhanced_prediction_interface
            home_stats = team_stats[team_stats['team'] == home_team].iloc[-1]
            away_stats = team_stats[team_stats['team'] == away_team].iloc[-1]
            
            # Recreate the feature vector exactly as in training
            base_features, interaction_features = [], []
            stats_to_check = ['off_epa', 'adj_off_epa', 'off_success', 'adj_off_success', 'def_epa', 'adj_def_epa', 'def_success', 'adj_def_success', 'total_yards', 'turnover_rate', 'adj_turnover_rate']
            interaction_terms = [('off_epa', 'def_epa'), ('adj_off_epa', 'adj_def_epa'), ('off_success', 'def_success'), ('adj_off_success', 'adj_def_success')]
            
            for stat in stats_to_check:
                diff = home_stats.get(f'ar1_{stat}', 0) - away_stats.get(f'ar1_{stat}', 0)
                base_features.append(diff)
            for term1, term2 in interaction_terms:
                interaction = home_stats.get(f'ar1_{term1}', 0) * away_stats.get(f'ar1_{term2}', 0)
                interaction_features.append(interaction)

            features = np.array([base_features + interaction_features])
            features_scaled = scaler.transform(features)
            
            # Handle stacked model prediction
            meta_model, base_models = model_info
            feature_names = [f'diff_ar1_{s}' for s in stats_to_check] + ['ar1_off_epa_home_x_ar1_def_epa_away', 'ar1_adj_off_epa_home_x_ar1_adj_def_epa_away', 'ar1_off_success_home_x_ar1_def_success_away', 'ar1_adj_off_success_home_x_ar1_adj_def_success_away']
            features_df = pd.DataFrame(features_scaled, columns=feature_names)
            win_prob = predict_stacked_model(features_df, base_models, meta_model)
            win_prob = float(win_prob[0]) if isinstance(win_prob, np.ndarray) else float(win_prob)

            st.subheader("Prediction Result")
            col1, col2 = st.columns(2)
            with col1:
                st.metric(f"{home_team} Win Probability", f"{win_prob:.1%}")
                st.progress(win_prob)
            with col2:
                st.metric(f"{away_team} Win Probability", f"{(1-win_prob):.1%}")
                st.progress(1 - win_prob)

def display_spread_tab(models_dict):
    st.header("üìä Point Spread Prediction")
    if 'spread' not in models_dict:
        st.warning("Point spread model is not available.")
        return

    model, scaler, team_stats, _ = models_dict['spread']
    available_teams = sorted(team_stats['team'].unique())
    
    col1, col2 = st.columns(2)
    with col1:
        home_team = st.selectbox("Select Home Team", available_teams, index=2)
    with col2:
        away_team = st.selectbox("Select Away Team", available_teams, index=3)

    if st.button("Predict Point Spread", type="primary"):
        if home_team == away_team:
            st.error("Home and Away teams cannot be the same.")
            return
        
        with st.spinner("Calculating..."):
            home_stats = team_stats[team_stats['team'] == home_team].iloc[-1]
            away_stats = team_stats[team_stats['team'] == away_team].iloc[-1]
            
            features = []
            stats_to_check = ['off_epa', 'adj_off_epa', 'off_success', 'adj_off_success', 'def_epa', 'adj_def_epa', 'def_success', 'adj_def_success', 'third_down_rate', 'adj_third_down_rate', 'rz_efficiency', 'adj_rz_efficiency', 'turnover_rate', 'adj_turnover_rate']
            for stat in stats_to_check:
                diff = home_stats.get(f'ar1_{stat}', 0) - away_stats.get(f'ar1_{stat}', 0)
                features.append(diff)

            features_scaled = scaler.transform(np.array([features]))
            spread = model.predict(features_scaled)[0]

            st.subheader("Prediction Result")
            if spread > 0:
                st.metric(label="Predicted Winner", value=f"{home_team}", delta=f"{spread:.1f} points")
            else:
                st.metric(label="Predicted Winner", value=f"{away_team}", delta=f"{-spread:.1f} points")


def display_player_yardage_tab(models_dict, weekly_df):
    st.header("üèÉ Player Yardage Prediction")
    if 'players' not in models_dict:
        st.warning("Player yardage models are not available.")
        return

    player_models = models_dict['players']
    position = st.selectbox("Select Position", list(player_models.keys()))

    model, _, player_data, feature_names = player_models[position]
    
    # Filter players and teams based on selected position
    available_players = sorted(player_data['player_display_name'].dropna().unique())
    
    # --- THIS IS THE CORRECTED LINE ---
    available_opponents = sorted(weekly_df['opponent_team'].dropna().unique())
    
    col1, col2 = st.columns(2)
    with col1:
        player_name = st.selectbox("Select Player", available_players)
    with col2:
        opponent = st.selectbox("Select Opponent", available_opponents)

    if st.button("Predict Player Yards", type="primary"):
        with st.spinner(f"Projecting yards for {player_name}..."):
            player_history = player_data[player_data['player_display_name'] == player_name]
            if player_history.empty:
                st.error(f"No data found for {player_name}")
                return

            latest_data = player_history.iloc[-1]
            player_id = latest_data['player_id']
            
            opp_data = player_data[player_data['opponent_team'] == opponent]
            opp_def_epa = opp_data['opp_def_epa'].mean() if not opp_data.empty else player_data['opp_def_epa'].mean()
            opp_def_success = opp_data['opp_def_success'].mean() if not opp_data.empty else player_data['opp_def_success'].mean()

            features = []
            for feat in feature_names:
                if feat == 'opp_def_epa': features.append(opp_def_epa)
                elif feat == 'opp_def_success': features.append(opp_def_success)
                else: features.append(latest_data.get(feat, 0))

            X_pred = pd.DataFrame([features], columns=feature_names)
            prediction = model.predict(X_pred, groups=[player_id])[0]

            yard_type = "Passing" if position == "QB" else "Rushing" if position == "RB" else "Receiving"
            st.metric(f"Predicted {yard_type} Yards", f"{prediction:.1f}")

# In app.py (add this new function)

def display_neural_tab(models_dict):
    st.header("üß† Neural Network Predictions")
    if 'neural' not in models_dict or not models_dict['neural']:
        st.warning("Neural network models are not available or failed to train.")
        return

    neural_models = models_dict['neural']
    
    # Use tabs to separate the two types of neural models
    tab1, tab2 = st.tabs(["Neural Game Outcome", "Neural Player Yardage"])

    with tab1:
        st.subheader("üèà Neural Game Outcome Prediction")
        if 'neural_binary' not in neural_models:
            st.warning("Neural game outcome model is not available.")
        else:
            model, team_encoder, team_stats = neural_models['neural_binary']
            available_teams = sorted(team_stats['team'].unique())
            
            col1, col2 = st.columns(2)
            with col1:
                home_team = st.selectbox("Select Home Team (NN)", available_teams, index=4, key="nn_home")
            with col2:
                away_team = st.selectbox("Select Away Team (NN)", available_teams, index=5, key="nn_away")

            if st.button("Predict Win Probability (Neural Network)", type="primary"):
                if home_team == away_team:
                    st.error("Home and Away teams cannot be the same.")
                else:
                    with st.spinner("Running neural prediction..."):
                        try:
                            # Prepare sequences of recent game stats for both teams
                            home_sequences, _, _ = prepare_team_sequences(team_stats[team_stats['team'] == home_team], 5, 'win')
                            away_sequences, _, _ = prepare_team_sequences(team_stats[team_stats['team'] == away_team], 5, 'win')

                            if len(home_sequences) == 0 or len(away_sequences) == 0:
                                st.error("Not enough historical data for one of the teams to create a sequence.")
                                return

                            # Use the most recent sequence for prediction
                            home_seq_latest = home_sequences[-1:]
                            away_seq_latest = away_sequences[-1:]

                            # Encode team IDs for the embedding layer
                            home_encoded = team_encoder.transform([home_team])
                            away_encoded = team_encoder.transform([away_team])

                            # Predict each team's "strength" score from the model
                            home_pred = model.predict([home_encoded, home_seq_latest])[0][0]
                            away_pred = model.predict([away_encoded, away_seq_latest])[0][0]

                            # Normalize the scores to get a win probability
                            total_pred = home_pred + away_pred
                            home_win_prob = home_pred / total_pred if total_pred > 0 else 0.5
                            
                            st.subheader("Neural Prediction Result")
                            c1, c2 = st.columns(2)
                            with c1:
                                st.metric(f"{home_team} Win Probability", f"{home_win_prob:.1%}")
                                st.progress(float(home_win_prob))
                            with c2:
                                st.metric(f"{away_team} Win Probability", f"{(1-home_win_prob):.1%}")
                                st.progress(float(1-home_win_prob))
                        except Exception as e:
                            st.error(f"An error occurred during neural prediction: {e}")

    with tab2:
        st.subheader("üèÉ Neural Player Yardage Prediction")
        if 'neural_players' not in neural_models or not neural_models['neural_players']:
            st.warning("Neural player yardage models are not available.")
        else:
            player_models = neural_models['neural_players']
            position = st.selectbox("Select Position (NN)", list(player_models.keys()), key="nn_pos")

            if position in player_models:
                model, player_encoder, player_data, target_scaler = player_models[position]
                
                available_players = sorted(player_data['player_display_name'].dropna().unique())
                all_teams = sorted(player_data['opponent_team'].dropna().unique())

                col1, col2 = st.columns(2)
                with col1:
                    player_name = st.selectbox("Select Player (NN)", available_players, key="nn_player")
                with col2:
                    opponent = st.selectbox("Select Opponent (NN)", all_teams, key="nn_opponent")

                if st.button("Predict Player Yards (Neural Network)", type="primary"):
                    with st.spinner(f"Projecting yards for {player_name} with neural net..."):
                        try:
                            player_history = player_data[player_data['player_display_name'] == player_name]
                            if player_history.empty:
                                st.error(f"No data found for {player_name}")
                                return
                            
                            player_id = player_history.iloc[-1]['player_id']
                            target_col = 'passing_yards' if position == 'QB' else 'rushing_yards' if position == 'RB' else 'receiving_yards'
                            
                            # Prepare player's recent game sequence
                            sequences, _, _ = prepare_player_sequences(player_history, 4, target_col)
                            
                            if len(sequences) == 0:
                                st.error(f"Not enough game history for {player_name} for a neural prediction.")
                                return

                            latest_sequence = sequences[-1:]
                            encoded_player = player_encoder.transform([player_id])

                            # Predict the scaled yardage value
                            prediction_scaled = model.predict([encoded_player, latest_sequence])
                            
                            # Use the scaler to convert the prediction back to actual yards
                            prediction = target_scaler.inverse_transform(prediction_scaled)[0][0]

                            yard_type = "Passing" if position == "QB" else "Rushing" if position == "RB" else "Receiving"
                            st.metric(f"Predicted {yard_type} Yards", f"{prediction:.1f}")
                        except Exception as e:
                            st.error(f"An error occurred during neural player prediction: {e}")

# --- 4. MAIN APPLICATION LAYOUT ---

# Title of the app
st.title("üèà NFL Prediction System")

# Load data and train models (this will be instant after the first run)
pbp_df, weekly_df = load_all_data()
models_dict = train_all_models(pbp_df, weekly_df)


st.sidebar.title("Navigation")
app_mode = st.sidebar.radio(
    "Choose a Prediction Model",
    ["Home", "Game Outcome", "Point Spread", "Player Yardage", "Neural Predictions"] # <-- ADD THIS
)

# Render the selected page
if app_mode == "Home":
    display_home_page(pbp_df, weekly_df, models_dict)
elif app_mode == "Game Outcome":
    display_binary_outcome_tab(models_dict)
elif app_mode == "Point Spread":
    display_spread_tab(models_dict)
elif app_mode == "Player Yardage":
    display_player_yardage_tab(models_dict, weekly_df)
# ADD THIS BLOCK
elif app_mode == "Neural Predictions":
    display_neural_tab(models_dict)
# Add elif blocks for other models (e.g., Total Points) following the same pattern.
